"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryAnalyzer = void 0;
class BinaryAnalyzer {
    constructor() {
        this._target = [];
    }
    addTarget(name, filter, type, postProcess) {
        this._target.push({ name, filter, type, postProcess });
        return this;
    }
    addTargetByLength(name, length, type, postProcess) {
        return this.addTarget(name, new Array(length).fill(-1), type, postProcess);
    }
    addGroup(name, fnOrAnalyzer) {
        const analyzer = fnOrAnalyzer instanceof BinaryAnalyzer
            ? fnOrAnalyzer
            : fnOrAnalyzer(new BinaryAnalyzer());
        this._target.push({ name, filter: analyzer });
        return this;
    }
    /**
     * 登録済みbinaryAnarlyzerのGroupを解除して、Flatな条件Arrayを作る
     */
    flat() {
        return this._target.reduce((acc, val) => {
            if (val.filter instanceof BinaryAnalyzer) {
                return [...acc, ...val.filter.flat()];
            }
            return [...acc, ...val.filter];
        }, []);
    }
    length() {
        return this.flat().length;
    }
    validate(target) {
        const targetArray = this._convertToNumberArray(target);
        const flat = this.flat();
        if (flat.length > targetArray.length) {
            return false;
        }
        for (let index = 0; index < flat.length; index++) {
            if (flat[index] === -1) {
                continue;
            }
            if (targetArray[index] === flat[index]) {
                continue;
            }
            return false;
        }
        return true;
    }
    getAllData(target) {
        const targetArray = this._convertToNumberArray(target);
        if (!this.validate(targetArray)) {
            return null;
        }
        const result = {};
        let index = 0;
        for (const one of this._target) {
            if (one.filter instanceof BinaryAnalyzer) {
                const newTarget = targetArray.slice(index, index + one.filter.length());
                result[one.name] = one.filter.getAllData(newTarget);
            }
            else {
                const row = one;
                const numberArray = targetArray.slice(index, index + one.filter.length);
                const value = this._convertToValue(row.type, numberArray);
                result[one.name] = row.postProcess ? row.postProcess(value) : value;
            }
            if (one.filter instanceof BinaryAnalyzer) {
                index += one.filter.length();
            }
            else {
                index += one.filter.length;
            }
        }
        return result;
    }
    _convertToValue(type, numberArray) {
        if (type === 'Ascii') {
            return String.fromCharCode(...numberArray);
        }
        else if (type === 'UIntBE') {
            return numberArray.reduce((acc, val) => (acc << 8) + val, 0);
        }
        else if (type === 'UIntLE') {
            return numberArray.reverse().reduce((acc, val) => (acc << 8) + val, 0);
        }
        return numberArray;
    }
    _convertToNumberArray(target) {
        var _a;
        if (Array.isArray(target)) {
            return target;
        }
        const tokens = target.match(/[0-9a-z]{2}/gi); // splits the string into segments of two including a remainder => {1,2}
        return (_a = tokens === null || tokens === void 0 ? void 0 : tokens.map(t => parseInt(t, 16))) !== null && _a !== void 0 ? _a : [];
    }
}
exports.BinaryAnalyzer = BinaryAnalyzer;
